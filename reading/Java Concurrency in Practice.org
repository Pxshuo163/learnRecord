* Java 并发编程实战

* TODO 第一章 简介

* TODO 第一部分 基础知识                                               :部分:

* DONE 第二章 线程安全

+ [X] 线程安全两个重要概念
  - 共享 :: 多个线程同时访问
  - 可变 :: 对象的状态(也就是变量)是可变的
  - [X] 引申出来
    - [X] 如果向确保线程安全,从三个方面入手:不共享,不可变或者使用同步机制
+ [ ] 线程安全的类
  + [ ] 无状态的类,没有用于共享的可变状态
    + [ ] 也可以理解为没有成员变量的意思(变量如果可变)
+ [ ] 竞态条件 :: 就是多线程中同时访问一条数据造成的数据失效
+ [ ] 需要同步
  + 存在一个可变状态,如果这时候包含了一个静态条件,那么会产生同步问题
    + 将可变态变为不可变态,也就是将变量变为线程安全类即可,竞态条件使用安全方法
    + 就是变态变为不变态,竞态变为非竞态
    + 但并不完全正确
  + 当存在多个不变态时,多个竞态条件使多个不变态在这个对象中成为了一个变态,也会产生同步问题
    + 由于多个竞争条件会使各个线程中的多个不变态的状态不同
    + 所以需要对多个竞态条件进行加锁,使其变为一个原子操作,也就是非竞态条件
    + 由于竞态变为了非竞态,所以复合的变态就变回了非变态(获取的时候还是要加锁)
  + 当组合使用两个非竞态的方法时(添加了同步),此时会产生竞态,也就是产生同步问题
    + 一般是在对象外,应该再使用同步即可
  + 变态变为不变态的原因在于竞态条件的消除,而与变态无关
    + 所以以上三个,1为通过线程安全类消除了竞态条件
    + 2为通过同步代码块消除了竞态条件
    + 3为通过同步代码块消除了竞态条件

** DONE 总结

1. 产生线程安全的三个要素:共享,可变状态与竞态条件,竞态条件是关键
2. 要解决线程安全问题,可以取消共享,消除可变状态,或者使用同步,也就是消除竞态条件
3. 解决线程安全问题
   1. 存在一个变态时,如果方法中存在一个竞态条件时,将变态变为线程安全类,即可消除竞态条件
   2. 存在多个变态时,需要使用同步块来消除竞态条件
   3. 即使使用线程安全类,在调用不同线程安全方法的时候也可能产生竞态条件,也需要使用同步块进行消除
4. 竞态条件
   1. 读取-修改-存入
   2. 先检查后执行

* TODO 第三章 对象的共享

+ 同步除了为了保护线程安全,还可以解决内存可见
  + 就是当一个线程修改了一个数据之后,其他线程可以立即看到修改后的结果
+ 命令重排导致数据失效
  + 数据失效只是读取的是旧数据,属于最低安全保证
  + 但如果时非volatile修饰的64位变量(double与long)则没有最低安全保证
    + 普通32位变量的写入操作是原子性的,但64位分为了2个32位进行操作,所以读取的值可能是完全没见过的值
+ 失效数据
  + 失效数据就是某个线程修改了数据,但是其他线程读取时读到的并不是修改后的数据,这个时候数据就失效了
  + 通过volatile可以将变量变为内存可见数据,当一个线程修改之后,及时对其他线程进行同步
  + volatile修饰的变量是一种轻量级的锁
    + 读取这个变量表示获取到了锁
    + 写入这个变量表示释放了锁
    + 因为其他线程读到这个变量时,也可以读到写入这个变量之前所有修改过的变量
      + 只有读到时才算是获得了锁
  + volatile只能确保可见性,无法确保原子性
  
  + 引用逸出
    + 就是类中的成员引用被外部的类获取
  + this逸出
    + 指的是在构造阶段this被外部对象获取到(如注册到某个主题下)
      + 是由于这个时候该对象可能还没有完全构造完成
      + 所以需要通过工厂方式,将构造方法与注册方法隔离开来(P34)
+ 另一种解决线程安全的方案
  + 封装多个变态为一个不变态对象,从而消除竞态条件
