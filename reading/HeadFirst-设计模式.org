* Head First 设计模式

** 设计原则 [0/4]
+ [ ] 将应用中可能变化的地方独立出来,与那些不需要变化的代码区分开来
+ [ ] 针对接口编程,而不是针对实现编程
+ [ ] 多用组合,少用继承
+ [ ] 为了交互对象之间的松耦合设计而努力

* TODO 1. 设计模式入门-策略模式
  :LOGBOOK:
  CLOCK: [2018-05-28 周一 14:25]--[2018-05-28 周一 14:33] =>  0:08
  :END:

** 从一个提取特征的例子入手
*** 给鸭子添加一个飞的动作,应该加在哪里呢?
**** 加在父类上,可能有的鸭子没有飞的动作
**** 加在子类上,重复代码又会很多
*** 继承的方式:适用范围并不广,它属于可选属性,并不是所有子类都需要
*** 接口的方式:代码不会复用,在需要的地方只能自己进行实现
**** 提取FlyAble在需要的子类上进行实现
** TODO 策略模式
*** 将飞行与叫声各自单独抽象出接口,在具体的实例中注入进去或者在具体的类中使用对应的实例
*** 定义了算法簇,分别封装起来,让他们之间可以互相替换.
**** 这个模式让算法的变化独立于使用算法的客户
** 总结

+ [X] 所谓策略模式应该是遵循着多用组合,少用继承的原则
  + 辅之以接口等多态的特性,从而达到替换策略的目的


* TODO 2. 观察者模式
  :LOGBOOK:
  CLOCK: [2018-05-28 周一 14:34]--[2018-05-28 周一 16:11] =>  1:37
  :END:

** 概念
*** 定义了对象之间的一对多依赖,这样一来,当一个对象改变状态的时候,它的所有依赖者都会收到通知并自动更新.
*** JDK中使用的最多的模式之一
** 观察者模式
*** 出版者+订阅者
**** Subject :数据源
**** Observer:使用数据者,可以注册到Subject中,方便数据源在更新时对其进行通知
** 演化
*** 气象监测应用
**** 气象站通过传感器实时获取传感器信息
**** WeatherData从气象站获取信息
**** 将获取的信息更新到显示器上
*** 基本设计
**** 实现varChanged
***** 就是当有关注的变量发生变化时调用这个函数就可以了
***** 在Changed中直接使用对应的显示器引用来接收相应的变量
****** 一方面,显示器被写死了,无法灵活修改
****** 一方面变量被写死了,也无法修改
*** 观察者模式
**** 类图
***** Subject-接口
****** 注册,注销和通知观察者
***** SubjectImpl
****** 可以有设置和获取状态的方法
***** Observer-接口
****** 更新
***** ObserverImpl
****** 其中保留Subject的引用,new的时候传入对象可以实时注册进去
***** 这样的话,Subject可以单独的注册与注销观察者
****** 观察者也可以注册到或者从Subject处注销了
**** 两种类之间松耦合
*** TODO Java内置的观察者模式-Observable                           :练习重构:
**** Observable
***** setChanged
****** 可以自定义什么范围算作一个changed,防止频繁的通知
***** notifyObservers()
***** notifyObservers(Object arg)
****** 可以传给update固定的数据
**** Observer
***** update(Observable o, Object arg)
****** 可以获知是哪个主题提供的数据,和主题想要提供的数据
**** 内置的观察者模式通过继承来实现的,可能并不那么灵活
***** setChange依据多组合,少继承的原则,应该提取出去最好
** 总结
+ [X] 观察者模式
  + 相较于策略模式
    + 策略模式
      + 将类中易于变化的部分提取出来,成为一个可以替换的组合成员
      + 讨论的是类中方法与成员间的特点
      + 是对一个特性的提取与抽象
    + 观察者模式
      + 从结果上来看,像是对一组特性的提取与抽象
      + 管理了一组特性的行为
        + 通过数组收集引用,通过接口进行统一调用
      + 与依赖倒置有异曲同工之妙
        + 正常下,主题是依赖观察者的
          + 因为主题中含有观察者的引用
        + 通过观察者模式,主题添加观察者的行为外放到观察者中
          + 通过观察者接收主题的引用,自己主动调用加入到主题中
        + 从表面来看,变为了观察者依赖了主题,或者说主题接口
          + 主题也是依赖了观察者的接口
        + 从而控制反转了,由观察者主动构建对象间的关系
          + 原来是在主题中构建的对象间的关系,在主题类中写好的
          + 现在是由观察者在需要的时候进行动态构建

* TODO 3. 装饰者模式

** 总结
+ [ ] 还未进行整理
+ [ ] 装饰者模式
  + 类似于接口或者继承层面的递归操作
    + 或者不能叫做递归,而是链式调用
    + 对比现实,通过一个函数的return实现了各种插销,将各个部件连接起来
  + 特点
    + 父类抽象 :: A
      + 子类实体 :: AA[a-z]
      + 子类装饰抽象 :: AB
        + 子类装饰实体 :: ABA[a-z]
  + 通过设计好的接口,通过各种方式使用装饰者增强实体类
    + 用来解决类爆炸的情况
  + 上层的组合思想
    + 不是在一个类中进行组合
    + 是在框架层面上面向使用者的组合设计
      + 相当于将组合的思想又向上抽象了一个层次的感觉

* TODO 4. 工厂模式

** 总结
+ [ ] 还未整理
+ [ ] 工厂模式
  + 工厂模式使用来创建对象的一种封装
    + 将语言层面随意创建的自由度减小
    + 将创建对象的操作缩小到一个范围内
    + 通过继承与工厂方法划定了一个上下文环境,或者叫做命名空间
  + 工厂模式设定好了一系列的对象初始化框架
    + 类似流水线的机制,有一个明确的生产过程
      + 但是其中的具体的生产方式可以依据不同的工厂有不同的实现
      + 这种实现就是子类重写的实现
    + 确定一个框架,将可以变化的部分提取出来,交由子类进行实现
    + 工厂模式是为了生产产品的
      + 工厂类的产生在于产品的多种多样
      + 所以产品需要抽象出统一的接口,方便工厂类的使用,子类自行实现
  + 结构
    + 工厂抽象 :: 抽象类,框定产品的操作
      + 具体操作 :: 通过产品接口正常使用产品
      + 工厂方法 :: 抽象方法,交由子类去实现
    + 工厂子类 :: 根据自己的特点,实现对应的工厂类
      + 方法层面上实现了工厂方法
      + 继承层面上,实现了工厂模式
        + 通过类名引用了一个工厂方法,通过对应的工厂方法生产对应的产品
        + 也就是通过这种形式生成了一个上下文环境,产生了一个命名空间.
    + 产品抽象 :: 造成依赖倒置
      + 工厂依赖抽象进行统一化的产品处理
      + 产品子类依赖抽象进行具体的实现
    + 产品子类 :: 多元化
+ [ ] 抽象工厂模式
  + 用来获取一组不同的实例
    + 工厂模式只是获取一个实例

* TODO 5. 单例模式

+ [ ] 主要在于多线程下的安全如何保证
  + 实例化时候保证不会创建多个
  + 序列化与反序列化时确保只有一个

* TODO 6. 命令模式
  :LOGBOOK:
  CLOCK: [2018-06-11 周一 17:13]--[2018-06-11 周一 17:46] =>  0:33
  :END:

+ [ ] 命令模式
  + 结构
    + 调用者 :: 类似于观察者模式的循环调用update()
    + 命令接口 :: excute(),开灯,关灯是两个命令
      + 子类实现 :: 开灯,依赖于电灯的类

* TODO 7. 适配器模式与外观模式

** TODO 1. 适配器模式

+ [ ] 适配器模式
  + 通过组合的方式实现接口
    + 组合火鸡类来实现鸭子接口
    + 包装其他的类的实例来实现接口的方式

** TODO 2. 外观模式

+ [ ] 将复杂的业务调用抽象成简单的接口形式
  + 和重构类似

* TODO 8. 模板方法模式

+ [ ] 模板方法
  + 设定好一套流程
    + 将其中部分流程的工作下放到子类中去实现
    + 放置一些钩子作为默认值,可以使子类不用全部都进行实现

* TODO 9. 迭代器与组合模式

** TODO 1. 迭代器模式

+ [ ] 通过迭代器的方式统一化数组的访问(遍历)方式
+ [ ] 表现形式
  + 职责分类
    + 目标类 :: 就是数组
    + 主函数 :: 就是调用数组的人,准备遍历数组
    + 迭代器 :: 迭代器模式
  + 描述
    + 主函数 :: 依赖迭代器接口,获取数组,进行遍历
    + 迭代器 :: 声明一种接口,包含简单的遍历形式(hasNext,next)
    + 目标类 :: 实现接口
  + 总结
    + 主函数与目标类依赖于迭代器,两者都是针对迭代器接口进行扩展与修改的

** TODO 2. 组合模式

+ [ ] 将对多个对象的引用封装成一个数组
  + 然后通过遍历数组的形式对整个数组进行调用
  + 也可以封装为树的形式
+ [ ] 表现形式
  + 普通组合
    + 职责分类
      + 主函数 :: 一个类,其中包含了多个成员,这些成员实现了同一个接口
      + 目标对象 :: 这些实现了同一个接口的成员
      + 组合模式 :: 优化的模式
    + 描述
      + 主函数 :: 使用的时候遍历数组即可
      + 组合模式 :: 将这些成员变为一个数组,使用的时候直接遍历即可
      + 目标对象 :: 分散的具体成员变为了一个抽象的数组,大家统一行动
  + 树形组合
    + 通过接口抽象出叶子节点与普通节点的共同父节点.通过实现自己需要的方法来识别结点类型,遍历的时候统一遍历即可

* TODO 10. 状态模式

+ [ ] 状态模式通过组合来代替 ~if/else~ 语句
  + 普通状态模式
    + 变量代表状态
    + 方法代表操作
    + 每个方法度需要先判断状态,然后依据状态,执行操作,再改变状态
  + 状态模式
    + 将状态抽象为具体的类,顶层接口实现所有的方法
    + 各个状态依据自己的情况选择实现对应的方法
+ [ ] 策略模式通过组合来代替灵活且多重复的继承关系,所以不同
+ [ ] 表现形式
  + 职责分类
    + 主函数 :: 调用者
    + 目标对象 :: 状态机
    + 状态模式 :: 状态模式
  + 描述
    + 主函数 :: 调用方式不会产生变化
    + 目标对象 :: 从if语句中脱离出来,使用状态类代替原来的if/else
      + 目标对象本身需要提供当前状态的set方法与各个状态的get方法用于外部状态修改目标对象的状态
        + 因为具体的操作和状态改变都需要在具体的状态类中进行,这也是if方法体中的内容
    + 状态模式 :: 构造时需要传入目标对象的引用,用来控制目标对象
      + 方法中包含了具体的操作与状态变化

* TODO 11. 代理模式

** TODO 1. 远程代理

+ [ ] 客户端 -- 客户端代理 --- 服务器代理 -- 服务器
  + 两个代理类都来自于服务器,代理用于处理传输对象的序列化和反序列化
  + 并没有自己进行实现

** TODO 2. 虚拟代理

+ [ ] 类似于装饰者模式
  + 两者实现了同一个接口
  + 类AA装饰了类AB
  + 这个是为了优化AB,而不是为了解决类爆炸的问题
    + 就是解决的问题比较特殊
    + 装饰者设计上更倾向于普遍性
  + 例如: 图片的延迟加载

** TODO 3. 动态代理

+ [ ] Java本身支持
+ 结构
  + Bean :: 需要被代理的接口,java自带的需要这个
  + PersonBean :: 属于Bean的实现类
  + proxy :: 代理实例
    + 创建时需要传入的参数
      + pb实例 :: 被代理的那个对象,这个是依靠handler传递进来的
      + pb.classLoader :: 实例对象的类加载器
      + pb.interfaces :: 实例对象的接口数组
      + handler :: 加载时具体的处理方式,需要传入pb实例,匿名内部类的话,保证外部pb被final修饰即可
  + InvokerHandler :: 具体的处理方式
    + invoke(proxy, method, obj) :: 代理实例,执行的方法实例,执行的方法传入的参数
      + 所以需要外部传入pb实例来了解代理的对象是谁

* TODO 12. 复合模式

+ [ ] MVC
  + 视图 :: 展示
  + 控制器 :: 分析视图输入,并对应模型
  + 模型 :: 数据与逻辑

* TODO 13. 设计模式总结
