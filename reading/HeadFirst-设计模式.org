* Head First 设计模式

** 设计原则 [0/4]
+ [ ] 将应用中可能变化的地方独立出来,与那些不需要变化的代码区分开来
+ [ ] 针对接口编程,而不是针对实现编程
+ [ ] 多用组合,少用继承
+ [ ] 为了交互对象之间的松耦合设计而努力

* TODO 1. 设计模式入门-策略模式
  :LOGBOOK:
  CLOCK: [2018-05-28 周一 14:25]--[2018-05-28 周一 14:33] =>  0:08
  :END:

** 从一个提取特征的例子入手
*** 给鸭子添加一个飞的动作,应该加在哪里呢?
**** 加在父类上,可能有的鸭子没有飞的动作
**** 加在子类上,重复代码又会很多
*** 继承的方式:适用范围并不广,它属于可选属性,并不是所有子类都需要
*** 接口的方式:代码不会复用,在需要的地方只能自己进行实现
**** 提取FlyAble在需要的子类上进行实现
** TODO 策略模式
*** 将飞行与叫声各自单独抽象出接口,在具体的实例中注入进去或者在具体的类中使用对应的实例
*** 定义了算法簇,分别封装起来,让他们之间可以互相替换.
**** 这个模式让算法的变化独立于使用算法的客户
** 总结

+ [ ] 所谓策略模式应该是遵循着多用组合,少用继承的原则
  + 辅之以接口等多态的特性,从而达到替换策略的目的


* TODO 2. 观察者模式
  :LOGBOOK:
  CLOCK: [2018-05-28 周一 14:34]--[2018-05-28 周一 16:11] =>  1:37
  :END:

** 概念
*** 定义了对象之间的一对多依赖,这样一来,当一个对象改变状态的时候,它的所有依赖者都会收到通知并自动更新.
*** JDK中使用的最多的模式之一
** 观察者模式
*** 出版者+订阅者
**** Subject :数据源
**** Observer:使用数据者,可以注册到Subject中,方便数据源在更新时对其进行通知
** 演化
*** 气象监测应用
**** 气象站通过传感器实时获取传感器信息
**** WeatherData从气象站获取信息
**** 将获取的信息更新到显示器上
*** 基本设计
**** 实现varChanged
***** 就是当有关注的变量发生变化时调用这个函数就可以了
***** 在Changed中直接使用对应的显示器引用来接收相应的变量
****** 一方面,显示器被写死了,无法灵活修改
****** 一方面变量被写死了,也无法修改
*** 观察者模式
**** 类图
***** Subject-接口
****** 注册,注销和通知观察者
***** SubjectImpl
****** 可以有设置和获取状态的方法
***** Observer-接口
****** 更新
***** ObserverImpl
****** 其中保留Subject的引用,new的时候传入对象可以实时注册进去
****** 这样的话,Subject可以单独的注册与注销观察者
****** 观察者也可以注册到或者从Subject处注销了
**** 两种类之间松耦合
*** TODO Java内置的观察者模式-Observable                           :练习重构:
**** Observable
***** setChanged
****** 可以自定义什么范围算作一个changed,防止频繁的通知
***** notifyObservers()
***** notifyObservers(Object arg)
****** 可以传给update固定的数据
**** Observer
***** update(Observable o, Object arg)
****** 可以获知是哪个主题提供的数据,和主题想要提供的数据
**** 内置的观察者模式通过继承来实现的,可能并不那么灵活
***** setChange依据多组合,少继承的原则,应该提取出去最好

* TODO 3. 装饰者模式

* TODO 4. 工厂模式

* TODO 5. 单例模式

* TODO 6. 命令模式

* TODO 7. 适配器模式与外观模式

** TODO 1. 适配器模式

** TODO 2. 外观模式

* TODO 8. 模板方法模式

* TODO 9. 迭代器与组合模式

* TODO 10. 状态模式

* TODO 11. 代理模式

* TODO 12. 复合模式

* TODO 13. 设计模式总结
